<#@ template language="C#" hostspecific="true" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
// Automatically generated from Structures.txt

using JetBrains.Annotations;
using System.Buffers.Binary;
using System.Collections;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

// ReSharper disable once CheckNamespace
// ReSharper disable UseObjectOrCollectionInitializer
namespace LibRoton.Structures;

internal static class CodePage437
{
    private static readonly Lazy<Encoding> _encoding = new(() =>
    {
        CodePagesEncodingProvider.Instance.GetEncoding(437);
        Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);
        return Encoding.GetEncoding(437);
    });

    public static Encoding Encoding => _encoding.Value;
}
<#
    const StringComparison ignoreCase = StringComparison.OrdinalIgnoreCase;

    var endian = "LittleEndian";

    string GetReaderFunc(string type, string offset, string target, string source) =>
        "        " + type.ToLowerInvariant() switch 
        {
            "bool" or "boolean" => $"{target} = {source}[{offset}] != 0;",
            "byte" or "uint8" => $"{target} = {source}[{offset}];",
            "sbyte" or "int8" => $"{target} = unchecked((sbyte){source}[{offset}]);",
            "short" or "int16" => $"{target} = BinaryPrimitives.ReadInt16{endian}({source}[{offset}..]);",
            "ushort" or "uint16" => $"{target} = BinaryPrimitives.ReadUInt16{endian}({source}[{offset}..]);",
            "int" or "int32" => $"{target} = BinaryPrimitives.ReadInt32{endian}({source}[{offset}..]);",
            "uint" or "uint32" => $"{target} = BinaryPrimitives.ReadUInt32{endian}({source}[{offset}..]);",
            "long" or "int64" => $"{target} = BinaryPrimitives.ReadInt64{endian}({source}[{offset}..]);",
            "ulong" or "uint64" => $"{target} = BinaryPrimitives.ReadUInt64{endian}({source}[{offset}..]);",
            "float" or "single" => $"{target} = BinaryPrimitives.ReadSingle{endian}({source}[{offset}..]);",
            "double" => $"{target} = BinaryPrimitives.ReadDouble{endian}({source}[{offset}..]);",
            _ => $"{target} = {type}.Read({source}[{offset}..]);"
            };

    string GetWriterFunc(string type, string offset, string source, string target) =>
        "        " + type.ToLowerInvariant() switch 
        {
            "bool" or "boolean" => $"{target}[{offset}] = {source} ? (byte)1 : 0;",
            "byte" or "uint8" => $"{target}[{offset}] = {source};",
            "sbyte" or "int8" => $"{target}[{offset}] = unchecked((byte){source});",
            "short" or "int16" => $"BinaryPrimitives.WriteInt16{endian}({target}[{offset}..], {source});",
            "ushort" or "uint16" => $"BinaryPrimitives.WriteUInt16{endian}({target}[{offset}..], {source});",
            "int" or "int32" => $"BinaryPrimitives.WriteInt32{endian}({target}[{offset}..], {source});",
            "uint" or "uint32" => $"BinaryPrimitives.WriteUInt32{endian}({target}[{offset}..], {source});",
            "long" or "int64" => $"BinaryPrimitives.WriteInt64{endian}({target}[{offset}..], {source});",
            "ulong" or "uint64" => $"BinaryPrimitives.WriteUInt64{endian}({target}[{offset}..], {source});",
            "float" or "single" => $"BinaryPrimitives.WriteSingle{endian}({target}[{offset}..], {source});",
            "double" => $"BinaryPrimitives.WriteDouble{endian}({target}[{offset}..], {source});",
            _ => $"{type}.Write({target}[{offset}..], {source});"
            };

    var structureLines = File.ReadAllLines(Host.ResolvePath("Structures.txt"));
    string currentStructure = default;
    var structureIsArray = false;
    var readerLines = new List<string>();
    var writerLines = new List<string>();
    var structureLength = 0;

    var lineIndex = 0;
    while (lineIndex < structureLines.Length)
    {
        // Grab the next line.
        var line = structureLines[lineIndex].Split([' '], StringSplitOptions.RemoveEmptyEntries);
        if (line.Length < 1)
        {
            lineIndex++;
            continue;
        }

        if (currentStructure == null)
        {
#>

// Line <#= lineIndex #>
<#
            // Read structure type.
            if (!line[0].Equals("begin", ignoreCase))
                throw new Exception($"Expected 'begin' at {lineIndex}");

            if (line.Length < 2)
                throw new Exception($"Expected 'struct' or array type at {lineIndex}");

            if (line[1].Equals("struct", ignoreCase))
            {
                // Parse 'struct' block.
                if (line.Length < 3)
                    throw new Exception($"Expected struct name at {lineIndex}");

                if (line.Length < 4)
                    throw new Exception($"Expected struct size at {lineIndex}");

                structureIsArray = false;
                currentStructure = line[2];
                structureLength = int.Parse(line[3]);
#>
[PublicAPI]
[StructLayout(LayoutKind.Explicit, Size = Size, Pack = 1)]
public struct <#= line[2] #>
{
    public const int Size = <#= structureLength #>;

<#
                lineIndex++;
                continue;
            }

            currentStructure = line[2];

            // Parse array block.
            if (line.Length < 3)
                throw new Exception($"Expected array name at {lineIndex}");

            if (line.Length < 4)
                throw new Exception($"Expected array length at {lineIndex}");

            structureIsArray = true;
            structureLength = int.Parse(line[3]);
#>
[PublicAPI]
[InlineArray(Length)]
public struct <#= line[2] #> : IEnumerable<<#= line[1] #>>
{
    public const int Length = <#= structureLength #>;

    private <#= line[1] #> _element0;

    public static int Size => Length * Marshal.SizeOf<<#= line[1] #>>();

    public Span<<#= line[1] #>> AsSpan() =>
        MemoryMarshal.CreateSpan(ref _element0, Length);

    public void CopyTo(Span<<#= line[1] #>> span) =>
        AsSpan().CopyTo(span);

    public static <#= line[2] #> Read(ReadOnlySpan<byte> span) =>
        MemoryMarshal.Cast<byte, <#= line[2] #>>(span)[0];

    public static <#= line[2] #> Read(Stream stream)
    {
        Span<<#= line[2] #>> values = stackalloc <#= line[2] #>[1];
        stream.ReadExactly(MemoryMarshal.Cast<<#= line[2] #>, byte>(values));
        return values[0];
    }

    public static void Write(Span<byte> span, <#= line[2] #> value) =>
        MemoryMarshal.Cast<byte, <#= line[2] #>>(span)[0] = value;

    public static void Write(Stream stream, <#= line[2] #> value)
    {
        Span<<#= line[2] #>> values = stackalloc <#= line[2] #>[1];
        values[0] = value;
        stream.Write(MemoryMarshal.Cast<<#= line[2] #>, byte>(values));
    }

    public IEnumerable<<#= line[1] #>> AsEnumerable()
    {
        for (var i = 0; i < Length; i++)
            yield return this[i];
    }

    public IEnumerator<<#= line[1] #>> GetEnumerator() =>
        AsEnumerable().GetEnumerator();

    IEnumerator IEnumerable.GetEnumerator() => 
        GetEnumerator();

    public <#= line[1] #>[] ToArray() =>
        AsSpan().ToArray();
<#

            lineIndex++;
            continue;
        }

        if (line[0].Equals("endian", ignoreCase))
        {
            if (line.Length < 2)
                throw new Exception($"Expected endianness at {lineIndex}");

            endian = line[1].ToLowerInvariant() switch 
            {
                "little" => "LittleEndian",
                "big" => "BigEndian",
                _ => throw new Exception($"Expected 'big' or 'little' at {lineIndex}")
            };
        }

        if (line[0].Equals("extend", ignoreCase))
        {
            if (line.Length < 2)
                throw new Exception($"Expected extension type at {lineIndex}");

            switch (line[1].ToLowerInvariant())
            {
                case "string":
                    if (line.Length < 3)
                        throw new Exception($"Expected length field name at {lineIndex}");
                    if (line.Length < 4)
                        throw new Exception($"Expected data field name at {lineIndex}");
#>
    public string Text
    {
        get
        {
            var source = <#= line[3] #>.AsSpan();
            var length = Math.Min(<#= line[2] #>, source.Length);
            return CodePage437.Encoding.GetString(source[..length]);
        }
        set
        {
            var target = <#= line[3] #>.AsSpan();
            var length = CodePage437.Encoding.GetBytes(value, target);
            Length = (byte)length;
        }
    }

<#
                    break;
            }
            
            lineIndex++;
            continue;
        }

        if (line[0].Equals("end", ignoreCase))
        {
            if (!structureIsArray)
            {
#>

    public static <#= currentStructure #> Read(ReadOnlySpan<byte> span)
    {
        var result = new <#= currentStructure #>();
<#= string.Join(Environment.NewLine, readerLines) #>
        return result;
    }

    public static <#= currentStructure #> Read(Stream stream)
    {
        Span<byte> span = stackalloc byte[<#= structureLength #>];
        stream.ReadExactly(span);
        return Read(span);
    }

    public static void Write(Span<byte> span, <#= currentStructure #> value)
    {
<#= string.Join(Environment.NewLine, writerLines) #>
    }

    public static void Write(Stream stream, <#= currentStructure #> value)
    {
        Span<byte> span = stackalloc byte[<#= structureLength #>];
        Write(span, value);
        stream.Write(span);
    }
<#
            }

#>
}
<#
            readerLines.Clear();
            writerLines.Clear();
            currentStructure = null;
            structureIsArray = false;
            lineIndex++;
            continue;
        }

        if (structureIsArray)
            throw new Exception($"Expected 'end' at {lineIndex}");

        if (line.Length < 2)
            throw new Exception($"Expected field type at {lineIndex}");

        if (line.Length < 3)
            throw new Exception($"Expected field name at {lineIndex}");

        var fieldOffset = int.Parse(line[0]);
#>
    [FieldOffset(<#= fieldOffset #>)] public <#= line[1] #> <#= line[2] #>;
<#
        readerLines.Add(GetReaderFunc(line[1], fieldOffset.ToString(), $"result.{line[2]}", "span"));
        writerLines.Add(GetWriterFunc(line[1], fieldOffset.ToString(), $"value.{line[2]}", "span"));
        lineIndex++;
    }
#>
